title: 数组去重的十种方法
date: 2018-06-07 11:12
categories: yuxue
tags:
- 数组去重
---

数组去重可以说是老生常谈的话题了，工作中经常用到，面试中经常问到。那接下来就对数组去重这个老梗，做一个简单的总结与记录。

## 一、 双重遍历

```javascript
let arr = [6, 6, 6, 5678, '5678', 'Start','start', true, true, null, null, undefined, undefined, NaN, NaN];

Array.prototype.unique = function() {
    for(let i=0;i<this.length;i++) {
        for(let j=i+1;j<this.length;j++) {
            if(this[i] === this[j]) {
                this.splice(j,1);
                j--;
            }
        }
    }
    return this
}
arr.unique();
```

```javascript
result: [6, 5678, "5678", "Start", "start", true, null, undefined, NaN, NaN]
```

### 优化

```javascript
let arr1 = [6, 6, 6, 5678, '5678', 'Start','start', true, true, null, null, undefined, undefined, NaN, NaN];		

Array.prototype.unique1 = function() {
   let newArr = [];
	for(let i=0;i<this.length;i++) {
		for(let j=i+1;j<this.length;j++) {
			if(this[i] === this[j]) {
				i++;
				j = i;
			}
		}
		newArr.push(this[i]);
	}
	return newArr;
}
arr1.unique1();
```

```javascript
result: [6, 5678, "5678", "Start", "start", true, null, undefined, NaN, NaN]
```

双重遍历的方式是最容易想到且最容易实现的方式，兼容性比较好，但是时间复杂度比较高；还有一点是不能对NaN进行去重。

## 二、 indexOf

```javascript
let arr2 =  [6, 6, 6, 5678, '5678', 'Start','start', true, true, null, null, undefined, undefined, NaN, NaN];

Array.prototype.unique2 = function() {
	let newArr = [];
	for(let i = 0; i<this.length; i++) {
		if(newArr.indexOf(this[i]) === -1) {
			newArr.push(this[i]);
		}
	}
	return newArr
}

arr2.unique2();
```

```javascript
result: [6, 5678, "5678", "Start", "start", true, null, undefined, NaN, NaN]
```

## 三、 数组下标判断

```javascript
let arr3 = [6, 6, 6, 5678, '5678', 'Start','start', true, true, null, null, undefined, undefined, NaN, NaN];

Array.prototype.unique3 = function() {
	let newArr = [];
	for(let i = 0;i<this.length;i++) {
		if(this.indexOf(this[i]) === i) {
			newArr.push(this[i]);
		}
	}
	return newArr
}
arr3.unique3();
```

```javascript
result: [6, 5678, "5678", "Start", "start", true, null, undefined]
```

因为indexOf使用的内部严格相等比较算法，所以在检索NaN时会返回-1，进而会导致方法3直接过滤掉了NaN。

## 四、 排序再去重

```javascript
let arr4 = [6, 6, 6, 5678, '5678', 'Start','start', true, true, null, null, undefined, undefined, NaN, NaN];

Array.prototype.unique4 = function() {
	let newArr = [];this.sort();
	for(let i=0; i<this.length; i++) {
		if(this[i] !== newArr[newArr.length-1]) {
			newArr.push(this[i]);
		}
	}
	return newArr
}

arr4.unique4();
```

```javascript
result: [5678, "5678", 6, NaN, NaN, "Start", null, "start", true, undefined]
```

优点是利用js内置的排序方法，速度快，比较的是排序后的相邻元素。最大的不同是更改了原数组的排序。

## 五、 利用对象的属性

```javascript
//版本1
let arr5 = [6, 6, 6, 5678, '5678', 'Start','start', true, true, null, null, undefined, undefined, NaN, NaN];

Array.prototype.unique5 = function() {
	let obj = {};
	let newArr = [];
	for(let i=0;i<this.length;i++) {
		if(!obj[this[i]]){
			newArr.push(this[i]);
			obj[this[i]] = 1;
		}
	}
	return newArr
}

arr5.unique5();
```

```javascript
result: [6, 5678, "Start", "start", true, null, undefined, NaN]
```
### 优化

```javascript
//版本2
let arr6 = [6, 6, 6, 5678, '5678', 'Start', 'start', true, true, null, null, undefined, undefined, NaN, NaN];				

Array.prototype.unique6 = function() {
	let newArr = [];
	let obj = {};
	let tmpKey;
	for(let i = 0;i<this.length;i++) {
		tmpKey = typeof this[i] + JSON.stringify(this[i]);
		if(!obj[tmpKey]) {
			obj[tmpKey] = 1;
			newArr.push(this[i]);
		}
	}
	return newArr;
}
arr6.unique6();
```

```javascript
result: [6, 5678, "5678", "Start", "start", true, null, undefined, NaN]
```

由于对象的键名只能是String，所以版本1的局限性在于

1. 无法区分隐式类型转换成字符串后一样的值，比如1和'1'

2. 无法处理复杂类型，比如对象（因为对象作为key会变成[object Object]）

3. 特殊数据，比如'__proto__'会挂掉，因为tmp对象的__proto__属性无法被重写

版本2的优化则解决了这三个问题。缺点就是实现的方式比较麻烦。



## 六、 reduce

```javascript
let arr7 =  [6, 6, 6, 5678, '5678', 'Start', 'start', true, true, null, null, undefined, undefined, NaN, NaN];

Array.prototype.unique7 = function () {
	let newArr = this.sort().reduce((initialValue, current) => {
		if(initialValue.length === 0 || initialValue[initialValue.length - 1] !== current){
			initialValue.push(current);
		}
		return initialValue;
	}, []);
	return newArr;
}
arr7.unique7();
```

```javascript
result: [5678, "5678", 6, NaN, NaN, "Start", null, "start", true, undefined]
```
原理实际同方法四，都是进行排序后比较相邻的两个值。

## 七、 filter

```javascript
let arr8 = [6, 6, 6, 5678, '5678', 'Start','start', true, true, null, null, undefined, undefined, NaN, NaN];

Array.prototype.unique8 = function() {
	return this.filter(function(ele,index,res) {
		return res.indexOf(ele) === index;
	});
}

console.log(arr8.unique8());
```

```javascript
result: [6, 5678, "5678", "Start", "start", true, null, undefined]
```

## 八、 es6 includes
```javascript
let arr9 = [6, 6, 6, 5678, '5678', 'Start', 'start',  true, true, null, null, undefined, undefined, NaN, NaN];		

Array.prototype.unique9 = function() {
	let newArr = [];
	for(let i = 0;i<arr9.length;i++) {
		if(!newArr.includes(arr9[i])) {
			newArr.push(arr9[i]);
		}
	}
	return newArr;
}	
arr9.unique9();
```

```javascript
result: [6, 5678, "5678", "Start", "start", true, null, undefined, NaN]
```

与indexOf类似，但不同的是indexOf使用的严格比较，includes使用的是叫做SameValueZero的比较，规范中给出 If x is NaN and y is NaN, return true.也就是includes可以对NaN去重。

## 九、 es6 Map

```javascript
let arr10 = [6, 6, 6, 5678, '5678', 'Start','start', true, true, null, null, undefined, undefined, NaN, NaN];

Array.prototype.unique10 = function () {
	let newArr = [];
	let tmp = new Map();
	for(let i=0; i<arr10.length; i++){
		if(!tmp.get(arr10[i])){
			tmp.set(arr10[i], 1);
			newArr.push(arr10[i]);
		}
	}
	return newArr;
}
arr10.unique10();
```

```javascript
result: [6, 5678, "5678", "Start", "start", true, null, undefined, NaN]
```

## 十、 es6 Set

```javascript
let arr11 = [6, 6, 6, 5678, '5678', 'Start', 'start', true, true, null, null, undefined, undefined, NaN, NaN];		
console.log([...new Set(arr11)]);
	
```

```javascript
result: [6, 5678, "5678", "Start", "start", true, null, undefined, NaN]
```
利用set对象存储任何类型的唯一值的特性来达到去重的目的。

